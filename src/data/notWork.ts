export interface NotWorkTile {
  id: string;
  image?: string; // placeholder for future images
  color?: string;
}

export interface NotWorkCarouselData {
  rows: NotWorkTile[][]; // always 3 rows
  total: number;
}

export const NOT_WORK_SECTION_ID = 'not-work-section';

/**
 * generateNotWorkData
 * Creates N placeholder tiles and distributes them randomly into 3 rows
 * while keeping row counts roughly balanced (difference <= 1).
 */
export function generateNotWorkData(n: number = 30): NotWorkCarouselData {
  const tiles: NotWorkTile[] = Array.from({ length: n }).map((_, i) => ({
    id: `not-work-${i + 1}`,
    color: 'surface'
  }));

  // Shuffle using Fisher-Yates
  for (let i = tiles.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
  }

  const targetPerRow = Math.ceil(n / 3);
  const rows: NotWorkTile[][] = [[], [], []];
  tiles.forEach(tile => {
    rows.sort((a, b) => a.length - b.length); // smallest first
    if (rows[0].length < targetPerRow) {
      rows[0].push(tile);
    } else if (rows[1].length < targetPerRow) {
      rows[1].push(tile);
    } else {
      rows[2].push(tile);
    }
  });

  return { rows, total: n };
}

// Default exported data (can be regenerated by calling generateNotWorkData in component if dynamic desired)
export const notWorkCarousel = generateNotWorkData();